/**
 * Generate *.d.ts files from JSON Schemas in public/schema/
 *
 * Example:
 *   public/schema/pathwayMetadata.v1.json → src/types/pathwayMetadata.v1.d.ts
 *   → Root interface name: PathwayMetadataV1
 */
import path from "node:path";
import fs from "node:fs";
import fsp from "node:fs/promises";
import {
  compile,
  DEFAULT_OPTIONS,
  type CompilerOptions,
} from "json-schema-to-typescript";

const SCHEMA_DIR = path.resolve("src/schema");
const OUT_DIR = path.resolve("src/types");

// Keep absolute $id/$ref in schemas, but map this base URL to local files during typegen.
const BASE_URL = "http://pathways.rmi.org/schema/";

/**
 * Recursively list all .json schema files under SCHEMA_DIR.
 */
async function listSchemaFiles(dir: string): Promise<string[]> {
  const entries = await fsp.readdir(dir, { withFileTypes: true });
  const results: string[] = [];
  for (const e of entries) {
    const p = path.join(dir, e.name);
    if (e.isDirectory()) {
      results.push(...(await listSchemaFiles(p)));
    } else if (e.isFile() && e.name.endsWith(".json")) {
      results.push(p);
    }
  }
  return results;
}

/**
 * Derive a stable TypeScript type name from a filename (no directory), e.g.:
 *   pathwayMetadata.v1.json -> PathwayMetadataV1
 */
function typeNameFromFilename(fileName: string): string {
  const base = fileName.replace(/\.json$/i, ""); // pathwayMetadata.v1
  return base
    .split(".")
    .map((seg) => (seg ? seg.charAt(0).toUpperCase() + seg.slice(1) : seg))
    .join("");
}

/**
 * Custom resolver for @apidevtools/json-schema-ref-parser used by json-schema-to-typescript.
 * It intercepts absolute refs starting with BASE_URL and reads schemas from disk under SCHEMA_DIR.
 */
const httpSchemaResolver = {
  order: 1,
  canRead: (file: { url: string }) =>
    typeof file.url === "string" && file.url.startsWith(BASE_URL),
  read: async (file: { url: string }) => {
    const rel = file.url.replace(BASE_URL, ""); // e.g., 'common/label.v1.json'
    const full = path.join(SCHEMA_DIR, rel);
    return fsp.readFile(full, "utf8");
  },
};

async function generateAll() {
  // Ensure output directory exists (flat output: src/types/*.d.ts)
  if (!fs.existsSync(OUT_DIR)) {
    await fsp.mkdir(OUT_DIR, { recursive: true });
  }

  const files = await listSchemaFiles(SCHEMA_DIR);
  const schemaFiles = files.filter((f) => f.endsWith(".json"));

  console.log(`Found ${schemaFiles.length} schema files in ${SCHEMA_DIR}`);
  for (const inputPath of schemaFiles) {
    const fileName = path.basename(inputPath); // keep names stable regardless of subdir
    const typeName = typeNameFromFilename(fileName);
    const relPath = path.relative(SCHEMA_DIR, inputPath); // e.g. 'common/label.v1.json'
    const outFile = path.join(OUT_DIR, relPath.replace(/\.json$/i, ".d.ts"));
    await fsp.mkdir(path.dirname(outFile), { recursive: true }); // ensure subdirs exist

    try {
      const raw = await fsp.readFile(inputPath, "utf8");
      const schema = JSON.parse(raw);

      // Help the generator pick a nice root type name
      schema.title = typeName;

      console.log(
        `Generating ${path.relative(process.cwd(), outFile)} as ${typeName}`,
      );

      // Compose options. We add $refOptions to resolve absolute http refs from disk.
      const options: CompilerOptions = {
        ...DEFAULT_OPTIONS,
        // Keep your preferred banner/comment options here:
        bannerComment:
          "/**\n" +
          "* This file was automatically generated by json-schema-to-typescript.\n" +
          "* DO NOT MODIFY IT BY HAND. Instead, modify the source JSON Schema file,\n" +
          "* and run json-schema-to-typescript to regenerate this file.\n" +
          "*/",
        cwd: SCHEMA_DIR,
        additionalProperties: false,
        unreachableDefinitions: false,
        $refOptions: {
          resolve: {
            // Keep file resolver, add our custom one, and fully disable remote HTTP.
            file: true,
            http: false,
            pathways: {
              order: 1,
              canRead: (file: { url: string }) =>
                typeof file.url === "string" && file.url.startsWith(BASE_URL),
              read: async (file: { url: string }) => {
                const rel = file.url.replace(BASE_URL, ""); // e.g. 'common/label.v1.json'
                const full = path.join(SCHEMA_DIR, rel);
                return fsp.readFile(full, "utf8");
              },
            },
          },
        },
      };

      const ts = await compile(schema, typeName, options);
      await fsp.writeFile(outFile, ts, "utf8");
    } catch (err) {
      console.error("Error generating types:", err);
      process.exitCode = 1;
      // Continue attempting remaining files, but mark failure
    }
  }

  if (process.exitCode && process.exitCode !== 0) {
    process.exit(process.exitCode);
  }
}

generateAll().catch((err) => {
  console.error("Fatal error in type generation:", err);
  process.exit(1);
});
